from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse
from random import randint
from math import factorial, isqrt
import sys

sys.set_int_max_str_digits(100000)

with open('out_1', 'rb') as f:
    LEAK = f.readline().strip().decode()
    FLAG_CT = f.readline().strip().decode()
    f.close()

LEAK = eval(LEAK)
Q, P, M, leak1, leak2 = int(LEAK[0]), int(LEAK[1]), int(LEAK[2]), int(LEAK[3]), int(LEAK[4])

def bezout(a, b):
    if b == 0:
        return (1, 0)
    else:
        x1, y1 = bezout(b, a % b)
        x, y = y1, x1 - (a // b) * y1
        return (x, y)

def modexp(base, exp, mod):
    if exp < 0:
        base = inverse(base, mod)
        exp = -exp
    return pow(base, exp, mod)

# Step 1: Find (r1, r2) from (Q, P)
t = Q + 2*P  # (x+y)^2 = x^2 + 2xy + y^2
S = isqrt(t)

delta = S**2 - 4 * P  # x^2 - Sx + P = 0 --> r1, r2 = (-b +- delta) / 2a
sqrt_delta = isqrt(delta)
r1_rec = (S + sqrt_delta) // 2
r2_rec = (S - sqrt_delta) // 2
print(f'[+] Found r1, r2: {r1_rec}, {r2_rec}')

# Step 2: Find (a, b) from (r1, r2) -- Probalistic Exploit with Prob = 50%
if randint(0, 1) == 0:
    a, b = bezout(r1_rec, r2_rec)
else:
    a, b = bezout(r2_rec, r1_rec)

part1 = modexp(leak1, a, M)
part2 = modexp(leak2, b, M)
leak_rec = (part1 * part2) % M
print(f'[+] Found leak: {leak_rec}')

# Step 3: Find k
for k_tmp in range(2**7+1, 2**12):
    ub = 2**1024 * factorial(k_tmp)
    if leak_rec < ub:
        k_rec = k_tmp
        print(f'[+] Found k: {k_rec}')
        break

p_rec = leak_rec // factorial(k_rec)
print(f'[+] Found p: {p_rec}')

N = (M+1) // factorial(k_rec)
assert N % p_rec == 0
q_rec = N // p_rec

e = 65537
d = pow(e, -1, (p_rec-1)*(q_rec-1))
print(FLAG_CT)
FLAG_CT = bytes_to_long(bytes.fromhex(FLAG_CT[2:]))
FLAG_PT = long_to_bytes(pow(FLAG_CT, d, N))
print('[FLAG]', FLAG_PT.decode())

