from pwn import *
from Crypto.Util.number import long_to_bytes
from math import gcd, isqrt
import string 

HOST = "localhost"
PORT = 5000

io = remote(HOST, PORT)

data = b""
while not b"FLAG_CT = [" in data:
    data += io.recvline()

data += io.recvuntil(b"]\n")

# Parsing di N, e, e FLAG_CT
lines = data.decode().splitlines()
N = int(lines[1].split("=", 1)[1].strip())
e = int(lines[2].split("=", 1)[1].strip())
FLAG_CT = [int(x.strip().rstrip(","), 16) for x in lines[4:-1]]
print(f'{N = }')
print(f'{e = }')
print(f'{FLAG_CT = }')

# Fermat factorization
print("[+] Factoring N...")
a = isqrt(N) + 1
while True:
    x = a * a - N
    y = isqrt(x)
    if y * y == x:
        p = a + y
        q = a - y
        if p * q == N:
            break
    a += 1

phi = (p - 1) * (q - 1)
d = pow(e, -1, phi)

# ECB Mapping
from string import printable

ALPHA = string.ascii_lowercase + string.digits + "{_}"
enc_map = {}

print("[+] Building ECB mapping...")
for c in ALPHA:
    io.sendlineafter(b"to encrypt:", c.encode())
    line = io.recvline().decode()
    if "Encrypted:" not in line:
        continue
    ct = int(line.strip().split("Encrypted:")[1], 16)
    pt = pow(ct, d, N)
    pt_bytes = long_to_bytes(pt)
    enc_map[pt_bytes] = c

# Decifra ogni blocco della flag
print("[+] Decrypting flag...")
flag = ""
for block in FLAG_CT:
    pt = pow(block, d, N)
    pt_bytes = long_to_bytes(pt)
    flag += enc_map.get(pt_bytes, "?")

print("[FLAG]", flag)
io.close()

